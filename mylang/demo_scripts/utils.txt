procedure filter(the_type:str, target_list:ArrayList) -> ArrayList{
  new_l = {}
  for target_list -> d{
      switch(d.type){
        case.eq the_type:
          new_l.addBack(d)
      }
  }
  return new_l
}

procedure range(start:int, stop:int){
  final_vals = {}
  for stop -> i{
    switch(i){
      case.ge start:
        final_vals.addBack(i)
    }
  }
  return final_vals
}


procedure isPrime(val:int) -> int{
  import utils
  for utils.range(2, val) -> i{
    switch(val%i){
      case.eq 0:
        return 0
    }
  }
  return 1
}



procedure sum(arlist:ArrayList){
  total = 0;
  for arlist -> i{
    print i
    total = total + i
  }
  return total
}


procedure lookupTable(vals:ArrayList, key){
  data_listing = {}
  for vals -> val{
    switch(val.type){
      case.ne "ArrayList":
          throw "scalar value in array found"

        }
    }
  for vals -> val{
    switch(key){
      case.eq val.itemAt(0):
        data_listing.addBack(val.itemAt(1))
    }
  }
    arr_len = data_listing.length()
    switch(arr_len){
      case.eq 1:
        return data_listing.itemAt(0)
      default:
        return data_listing
    }

  }




  scope HashTable{
    import utils
    hashlist = {}
    full_table = {}
    for utils.range(2, 200) -> i{
      new_l = {}
      hashlist.addBack(new_l)
      full_table.addBack(new_l)
    }
    global procedure getValueDefault(key, default_key){
    switch(key.type){
      case.eq "ArrayList":
        new_r = key.length()
      case.eq.optional "str":
        new_r = key.length()
        new_r = new_r.increment
      default:
        new_r = key
    }
    hashed_result = new_r%211
    new_hashed_result = hashed_result%200
    print hashed_result
    current = hashlist
    current_item = current.itemAt(new_hashed_result)
    switch(current_item.type){
      case.ne "ArrayList":
        return current_item
      default:
        return default_key
    }
    }
    global procedure getValue(key){
      switch(key.type){
        case.eq "ArrayList":
          new_r = key.length()
        case.eq.optional "str":
          new_r = key.length()
          new_r = new_r.increment
        default:
          new_r = key
      }
      hashed_result = new_r%211
      new_hashed_result = hashed_result%200
      print hashed_result
      current = hashlist
      current_item = current.itemAt(new_hashed_result)
      switch(current_item.type){
        case.ne "ArrayList":
          return current_item
        default:
          throw "key not found"
      }

    }
    global procedure addPair(key, value){
      switch(key.type){
        case.eq "ArrayList":
            r1 = key.length()
            new_r = r1+1
            hashed_result = new_r%211%200
        case.eq.optional "str":
          r1 = key.length()
          new_r = r1+1
          hashed_result = new_r % 211
          hashed_result = hashed_result%200

        default:
          hashed_result = key%211
          hashed_result = hashed_result%200
      }
      current_val = hashlist
      temp_item = current_val.itemAt(hashed_result)
      switch(temp_item.type){
        case.eq "ArrayList":
          current_length = temp_item.length()
        default:
          current_length = "False"
      }
      switch(current_length){
        case.eq "False":
          temp_holder = full_table
          placeholder = temp_holder.itemAt(hashed_result)
          placeholder.addBack(key)
          temp_holder.updateAt(hashed_result, placeholder)
          place = temp_item.itemAt(hashed_result)
          place.addBack(value)
          current_length.updateAt(hashed_result, place)
          hashlist = current_val
          full_table = place
        default:
          current_val.updateAt(hashed_result, value)
          hashlist = current_val
      }




    }

  }
